package com.gjavadoc.javadoctools

import com.gjavadoc.model.EntryPoint
import com.intellij.openapi.application.ReadAction
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.psi.JavaPsiFacade
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiManager
import com.intellij.psi.PsiMethod
import com.intellij.psi.codeStyle.CodeStyleManager
import com.intellij.psi.search.GlobalSearchScope
import com.intellij.psi.PsiClass

object JavadocWriter {
    /**
     * Write JavaDoc to the entry method.
     * Returns true if a doc comment was created or replaced.
     */
    fun writeMethod(project: Project, entry: EntryPoint, markdown: String, overwriteExisting: Boolean): Boolean {
        val method = ReadAction.compute<PsiMethod?, RuntimeException> { findEntryMethod(project, entry) } ?: return false
        // Build JavaDoc text from markdown and signature
        val docText = buildJavadocForMethod(project, method, markdown)
        val factory = JavaPsiFacade.getElementFactory(project)
        val newDoc = factory.createDocCommentFromText(docText)

        var updated = false
        WriteCommandAction.runWriteCommandAction(project) {
            val file = method.containingFile?.virtualFile
            if (file != null && !file.isWritable) return@runWriteCommandAction
            val old = method.docComment
            if (old != null) {
                if (overwriteExisting) {
                    old.replace(newDoc)
                    updated = true
                }
            } else {
                method.addBefore(newDoc, method.firstChild)
                updated = true
            }
            if (updated) CodeStyleManager.getInstance(project).reformat(method)
        }
        return updated
    }

    /**
     * Write JavaDoc to the entry class (CLASS scope tasks).
     */
    fun writeClass(project: Project, entry: EntryPoint, markdown: String, overwriteExisting: Boolean): Boolean {
        val psiClass = ReadAction.compute<PsiClass?, RuntimeException> {
            val scope = GlobalSearchScope.projectScope(project)
            JavaPsiFacade.getInstance(project).findClass(entry.classFqn, scope)
        } ?: return false
        val factory = JavaPsiFacade.getElementFactory(project)
        val docText = buildJavadocForClass(psiClass, markdown)
        val newDoc = factory.createDocCommentFromText(docText)
        var updated = false
        WriteCommandAction.runWriteCommandAction(project) {
            val file = psiClass.containingFile?.virtualFile
            if (file != null && !file.isWritable) return@runWriteCommandAction
            val old = psiClass.docComment
            if (old != null) {
                if (overwriteExisting) {
                    old.replace(newDoc)
                    updated = true
                }
            } else {
                psiClass.addBefore(newDoc, psiClass.firstChild)
                updated = true
            }
            if (updated) CodeStyleManager.getInstance(project).reformat(psiClass)
        }
        return updated
    }

    private fun buildJavadocForMethod(project: Project, method: PsiMethod, markdown: String): String {
        val desc = extractDescription(markdown).ifBlank { method.name }
        val paramDesc = parseInputParamTable(markdown)
        val returnDesc = parseReturnDescription(markdown)
        val sb = StringBuilder()
        sb.append("/**\n")
        // Split description into lines and prefix with ' * '
        for (line in desc.lines()) {
            sb.append(" * ").append(escapeForJavadoc(line.trim())).append("\n")
        }
        sb.append(" *\n")
        // @param from signature
        for (p in method.parameterList.parameters) {
            val name = p.name ?: "param"
            sb.append(" * @param ").append(name).append(" ")
            val d = paramDesc[name]
                ?: paramDesc.entries.firstOrNull { it.key.equals(name, ignoreCase = true) }?.value
            if (!d.isNullOrBlank()) sb.append(escapeForJavadoc(d))
            sb.append("\n")
        }
        // @return for non-void
        val rt = method.returnType
        if (rt != null && !rt.canonicalText.equals("void", ignoreCase = true)) {
            sb.append(" * @return ")
            if (!returnDesc.isNullOrBlank()) sb.append(escapeForJavadoc(returnDesc))
            sb.append("\n")
        }
        sb.append(" *\n")
        sb.append(" * Generated by GJavaDoc\n")
        sb.append(" */")
        return sb.toString()
    }

    private fun buildJavadocForClass(psiClass: PsiClass, markdown: String): String {
        val desc = extractDescription(markdown).ifBlank { psiClass.name ?: "" }
        val sb = StringBuilder()
        sb.append("/**\n")
        for (line in desc.lines()) {
            sb.append(" * ").append(escapeForJavadoc(line.trim())).append("\n")
        }
        sb.append(" *\n")
        sb.append(" * Generated by GJavaDoc\n")
        sb.append(" */")
        return sb.toString()
    }

    private fun escapeForJavadoc(text: String): String =
        text.replace("*/", "* /")

    private fun extractDescription(md: String): String {
        val lines = md.lines().map { it.trim() }
        // Prefer a line like "接口说明：..." or "说明：..."
        val keyLine = lines.firstOrNull { it.startsWith("接口说明：") || it.startsWith("接口说明:") || it.startsWith("说明：") || it.startsWith("说明:") }
        if (keyLine != null) {
            val idx = keyLine.indexOf('：').takeIf { it >= 0 } ?: keyLine.indexOf(':')
            if (idx >= 0) return keyLine.substring(idx + 1).trim()
        }
        // Otherwise, take the first non-empty, non-heading marker
        for (ln in lines) {
            if (ln.isBlank()) continue
            if (ln.startsWith("#")) continue
            // Skip obvious table header lines
            if (ln.startsWith("|") && ln.endsWith("|")) continue
            return ln
        }
        return ""
    }

    private fun parseInputParamTable(md: String): Map<String, String> {
        val res = LinkedHashMap<String, String>()
        val lines = md.lines()
        var i = 0
        var inInputSection = false
        fun isHeaderForInput(s: String): Boolean {
            val t = s.trim().trimStart('#').trim()
            return t.startsWith("输入参数") || t.startsWith("请求参数") || t.startsWith("参数列表") || t.equals("Parameters", true)
        }
        fun isHeaderForOutput(s: String): Boolean {
            val t = s.trim().trimStart('#').trim()
            return t.startsWith("输出参数") || t.startsWith("返回参数") || t.startsWith("响应参数") || t.startsWith("Response", true)
        }
        while (i < lines.size) {
            val ln = lines[i]
            if (isHeaderForInput(ln)) inInputSection = true
            if (isHeaderForOutput(ln)) inInputSection = false
            if (inInputSection && ln.trim().startsWith("|") && ln.contains("|")) {
                // Candidate table header
                val header = splitTableRow(ln)
                val lower = header.map { it.lowercase() }
                val nameIdx = lower.indexOfFirst { it.contains("参数名") || it.contains("名称") || it.contains("name") }
                val descIdx = lower.indexOfFirst { it.contains("说明") || it.contains("描述") || it.contains("desc") || it.contains("description") }
                if (nameIdx >= 0 && descIdx >= 0) {
                    // Skip alignment row if present
                    var j = i + 1
                    if (j < lines.size && isAlignmentRow(lines[j])) j++
                    while (j < lines.size) {
                        val row = lines[j].trim()
                        if (!row.startsWith("|")) break
                        val cells = splitTableRow(row)
                        if (cells.isEmpty()) break
                        val name = cells.getOrNull(nameIdx)?.trim().orEmpty()
                        val desc = cells.getOrNull(descIdx)?.trim().orEmpty()
                        if (name.isNotBlank() && desc.isNotBlank() && !res.containsKey(name)) res[name] = desc
                        j++
                    }
                    return res
                }
            }
            i++
        }
        // Fallback: parse the first name/desc table anywhere
        i = 0
        while (i < lines.size) {
            val ln2 = lines[i]
            if (ln2.trim().startsWith("|") && ln2.contains("|")) {
                val header = splitTableRow(ln2)
                val lower = header.map { it.lowercase() }
                val nameIdx = lower.indexOfFirst { it.contains("参数名") || it.contains("名称") || it.contains("name") }
                val descIdx = lower.indexOfFirst { it.contains("说明") || it.contains("描述") || it.contains("desc") || it.contains("description") }
                if (nameIdx >= 0 && descIdx >= 0) {
                    var j = i + 1
                    if (j < lines.size && isAlignmentRow(lines[j])) j++
                    while (j < lines.size) {
                        val row = lines[j].trim()
                        if (!row.startsWith("|")) break
                        val cells = splitTableRow(row)
                        if (cells.isEmpty()) break
                        val name = cells.getOrNull(nameIdx)?.trim().orEmpty()
                        val desc = cells.getOrNull(descIdx)?.trim().orEmpty()
                        if (name.isNotBlank() && desc.isNotBlank() && !res.containsKey(name)) res[name] = desc
                        j++
                    }
                    return res
                }
            }
            i++
        }
        return res
    }

    private fun parseReturnDescription(md: String): String? {
        val lines = md.lines()
        val pat = Regex("^(?i)(返回值|返回|return|response)[：:]\\s*(.+)")
        for (ln in lines) {
            val m = pat.find(ln.trim())
            if (m != null) return m.groupValues[2].trim()
        }
        // As a fallback, if there's an output table, list some field names
        val names = parseOutputFieldNames(md)
        if (names.isNotEmpty()) {
            val preview = names.take(4).joinToString(", ")
            return "包含字段：$preview"
        }
        return null
    }

    private fun parseOutputFieldNames(md: String): List<String> {
        val lines = md.lines()
        var i = 0
        var inOutput = false
        fun isHeaderForOutput(s: String): Boolean {
            val t = s.trim().trimStart('#').trim()
            return t.startsWith("输出参数") || t.startsWith("返回参数") || t.startsWith("响应参数") || t.equals("response", true) || t.equals("output", true)
        }
        while (i < lines.size) {
            val ln = lines[i]
            if (isHeaderForOutput(ln)) inOutput = true
            if (inOutput && ln.trim().startsWith("|") && ln.contains("|")) {
                val header = splitTableRow(ln)
                val lower = header.map { it.lowercase() }
                val nameIdx = lower.indexOfFirst { it.contains("参数名") || it.contains("名称") || it.contains("name") || it.contains("field") }
                if (nameIdx >= 0) {
                    val result = ArrayList<String>()
                    var j = i + 1
                    if (j < lines.size && isAlignmentRow(lines[j])) j++
                    while (j < lines.size) {
                        val row = lines[j].trim()
                        if (!row.startsWith("|")) break
                        val cells = splitTableRow(row)
                        if (cells.isEmpty()) break
                        val name = cells.getOrNull(nameIdx)?.trim().orEmpty()
                        if (name.isNotBlank()) result.add(name)
                        j++
                    }
                    return result
                }
            }
            i++
        }
        return emptyList()
    }

    private fun splitTableRow(row: String): List<String> {
        var s = row.trim()
        if (s.startsWith("|")) s = s.substring(1)
        if (s.endsWith("|")) s = s.substring(0, s.length - 1)
        return s.split('|').map { it.trim() }
    }

    private fun isAlignmentRow(line: String): Boolean {
        val t = line.trim()
        if (!t.startsWith("|")) return false
        // like |---|:---:|---|
        return Regex("^\n?").let { _ ->
            val body = t.trim().trim('|')
            body.split('|').all { seg -> seg.trim().all { ch -> ch == '-' || ch == ':' } }
        }
    }

    private fun findEntryMethod(project: Project, entry: EntryPoint): PsiMethod? {
        val vf = LocalFileSystem.getInstance().findFileByPath(entry.file) ?: return null
        val psiFile = PsiManager.getInstance(project).findFile(vf) ?: return null
        val doc = PsiDocumentManager.getInstance(project).getDocument(psiFile) ?: return null
        val lineIndex = (entry.line - 1).coerceAtLeast(0)
        val classes = psiFile.children.filterIsInstance<com.intellij.psi.PsiClass>()
        val targetName = entry.method.substringBefore('(')
        for (cls in classes) {
            val m = cls.methods.firstOrNull { m ->
                val r = m.textRange
                val startLine = doc.getLineNumber(r.startOffset)
                val endLine = doc.getLineNumber(r.endOffset)
                lineIndex in startLine..endLine || m.name == targetName
            }
            if (m != null) return m
        }
        return null
    }
}
